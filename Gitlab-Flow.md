# Gitlab Flow 工作流

Gitlab Flow 是Gitlab提出的一套代码管理及发布规范，它与Git Flow、Github Flow三种开发工作流被广泛使用。

## Git Flow

git 代码版本控制工具 官网：[https://git-scm.com/](https://git-scm.com/)

> 典型的长期维护master分支和develop分支，因为是FDD（功能驱动开发），所以会在协作开发中衍生出 功能分支（feature branch）、补丁分支（hotfix branch）、预发版分支（release branch），完成之后会合并到develop或者master分支，之后删除。优点是清晰可控，但这个模式是基于“版本发布”的，目标是一段时间产出一个新版本，不适合“持续发布”的网站开发。

## Github Flow

github 名站，开源社区，大牛集散地。提供给用户空间创建git仓储，保存用户的一些数据文档或者代码等，是开源代码库以及版本控制系统。官网：[https://www.gitlab.com/](https://www.gitlab.com/)

> 只有一个master长期分支，需要协同的人可以fork代码（其实就是新建了一个自己的分支，并且pull到了master上的代码），当你的功能需求代码完成之后，或者需要讨论的时候，就向master发起一个pull request。通知到别人评审、讨论、review你的代码，方便的是，在request提交之后评审的过程中，你还可以提交代码。等到你的request被accept，分支会合并到master，重新部署后，你原来的那个分支就可以删除啦。缺点是有时你的产品发布的代码版本和你master最新的版本并不是一个（比如因为苹果审核需要时间，那么你的代码就需要另一个分支来保留线上版本）。

## Gitlab Flow

gitlab 类似于github的平台，基于Git的项目管理软件，是一个用于仓库管理系统的开源项目。使用Git作为代码管理工具，并在此基础上搭建起来的web服务。官网：[https://www.github.com/](https://www.github.com/)

> 引入了“上游优先”（upsteam first）的原则。只存在一个主分支master，它是所有其他分支的"上游"。只有上游分支采纳的代码变化，才能应用到其他分支。版本发布"的项目，建议的做法是每一个稳定版本，都要从master分支拉出一个分支。使用gitlab建立group project，可以将成员全部添加进小组中，每个人的提交都以分支合并进master分支的方式进行，我们可以将master设置成protected branch，这样就做到了强制代码review的机制，利于提升代码的质量。Issue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。

## 项目分支说明

| 分支名 | 说明 |
|-----|------|
| master | 开发分支，也是主分支，对应我们的SIT环境；它是所有其他分支的"上游"。 master分支是prerelease分支（UAT环境）的"上游"|
| release | 预发布测试分支，对应UAT环境，release 分支又是 pre-production 发布分支的"上游"。 |
| pre-production | 预发布测试分支，对应Ver环境，pre-production 分支又是 production 发布分支的"上游"。 |
| production | 发布分支，对应PRO环境， |

> 只有上游分支采纳的代码变化，才能应用到其他分支。代码的变化必须由"上游"向"下游"发展。生产环境出现了bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，再cherry-pick到regression，这一步也没有问题，才进入prerelease，最近cherry-pick到production

## ISSUS、feature功能分支，bug修复分支等

创建功能分支(分支名：feature-XXX-XXX)或bug修复分支（分支名：hotfix-XXX-XXX）依据是Issue，即先有Issue，才有功能分支或bug修复分支。

Issue可由里程碑号进行框定。

### Issue 规则

- Issue是谁提出的，谁就要负责跟进Issue的解决情况开发进度。
- 每个Issue从属一个里程碑
- 提Issue的时候需要指定给一个人（谁来完成这个Issue），如果有些Issue不知道应该指派给谁，就直接指派给项目负责人
- 一个Issue可以是一个bug，一个建议，一个特性，总之是一项可以指派给一个具体的人的任务。
- 可以自己提Issue指派给自己，例如发现某块代码需要优化或者重构等等。
- 如果是代码相关的Issue，最后在git commit时最好能够关联对应的Issue
- 指派错误时可以重新指派：例如A被指派给一个Issue，但是A觉得这个应该由B来完成，这时A可以把这个Issue重新指派给B
- 当Issue被关闭时，其发起人应该定时（例如每天的某个时间）检查那些关闭列表（或者可以直接查看邮件列表），并检查，如果确实已经完成，可以打上一个已完成的标签，否则可以评论后重新打开该Issue。
- Issue的标题应该基本说明了问题，里面的描述应该更多的是辅助性描述

### 里程碑

> 里程碑功能主要用来把控项目的进度及节奏，对于我们来说，我们是以周为单位进行跟进。只有项目的master用户有权限设置和编辑里程碑。

- 所有项目以周为单位建立里程碑
- 原则上本周的里程碑不接受新的Issue，除非是严重的bug，需要马上修复
- 除了本周正在进行的里程碑之外，还应该往后规划一个或者多个里程碑
- 里程碑的名字以周五的日期为标识，例如“Ver-2017-07-21” （方便可以根据里程碑的名字对个人的工作进行汇总查看）
- 因里程碑名字没有自述能力，里程碑的描述里因枚举该版本已明确的功能需求，bug修复等描述。

### Code Review 代码评审

- 提交到master分支的代码应该强制进行代码评审，尽量做到“随提随审，随审随改”
- 除了指定需要相互review的同事，你对谁的代码有兴趣，都可以直接查看或者评论。

## 

## Gitlab Flow 的规则（官方的建议）

本规则目的是在团队合作开发过程中简化流程，从而产生有效和清晰的工作流。

### 1. 使用功能分支，不直接提交（commit）到 master 分支。
> 如果你从 SVN 转过来，举例来说，你会习惯于基于主干（trunk）的工作流程。而使用 Git 时，任何正在进行的操作，都应为之创建一个分支（branch），以便最终在合并（merge）之前进行代码审查（code review）。

### 2. 测试所有的提交，而不仅仅只在 master 分支上。
> 有些人将 CI 系统设置为只测试合并到 master 分支的东西。这太迟了！总是拥有绿色的 master 测试（译者注：绿色在 CI 里通常意味着测试通过，而红色意味着测试失败），人们会觉得有信心。例如，在开始开发新功能之前，人们不得不测试 master 分支那是没有意义和荒谬的。CI 并不昂贵，所以这样做是最好的。

### 3. 在所有的提交上，运行所有的测试（如果你的测试时间长于 5 分钟则让它们并行）。

> 如果您正工作在一个功能分支并添加新提交（commit），请随之运行测试。如果测试需要很长时间，请尝试并行运行。合并请求（merge requests）时，在服务器端来执行此操作以运行完整的测试套件。如果你有一个用于开发的测试套件，而另一个测试套件你只为新版本运行；那么设置并行测试并运行全部测试套件是值得的。

### 4. 在合并到 master 之前执行代码审查，而不是事后审查。

> 不要在一周结束时测试一切。当场就搞！这样你更有可能抓住可能导致问题的东西，而其他人也会努力提出解决方案。

### 5. 部署是自动的，并基于分支或标签（tag）。

> 如果您不想每次都部署 master 分支，那么你可以创建一个 production 分支；但你没理由用脚本（script）或登录到某个地方手动操作。自动化一切，或以特定分支来触发生产部署。

### 6. 标签（tag）是由用户设置的，而不是由 CI 创建。

> 应由用户来打标签（tag），并且基于此，CI 将执行一个动作。不应让 CI 去更改代码库。如果你需要非常详细的指标，你应该有一个服务器报告来详细说明新版本。

### 7. 发布（release）是基于标签（tag）的。

> 如果你打了 tag，则意味着创建了一个新版本。

### 8. 永远不对已推送的提交（pushed commits）进行变基（rebase）。

> 当你推送（push）到公共分支后，你就不该对其变基，因为这样会很难跟进你正在改进的内容，很难跟进测试结果是什么，而且它打破了 cherry-picking。有时我们在审查流程的后期要求代码贡献者合并及变基（git merge --squash），以使一些东西容易还原时，我们也会违背这一规则。但一般而言，准则是：代码应干净，修改历史应真实。

### 9. 每个人都从 master 分支开始工作，目标也是 master 分支。

> 这意味着没有任何长期分支。你可以检出 master 分支，构建功能，创建合并请求，并再次指向到 master 分支。在合并之前，应该进行完整的代码审查，而不应在代码审查和合并间存在任何中间阶段。

### 10. 在 master 分支中修正错误，其次再到发布分支。

> 如果你发现 bug，最糟的事莫过于你在刚发布的版本里修复了它，而未在 master 分支修复。为避免这种情况，应总是向前修复（fix forward）。在 master 中修复，然后 cherry-pick 到其他补丁发布分支。

### 11. 提交信息（commit message）应体现意图。

> 不仅要说明你做了什么，还应说明为什么这么做。如果解释一下为什么这么做，而不是用其他方式，这会更加有用。



